---
phase: 09-multi-agent-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - get-shit-done/bin/adapters/codex.cjs
  - get-shit-done/bin/adapters/gemini.cjs
  - get-shit-done/bin/adapters/opencode.cjs
  - get-shit-done/bin/gsd-tools.cjs
autonomous: true

must_haves:
  truths:
    - "Each adapter exports invokeAsync() alongside existing invoke() without breaking sync API"
    - "coplanner invoke-all command invokes all specified agents in true parallel via Promise.allSettled()"
    - "Per-agent timeouts are isolated -- one slow agent does not block others"
    - "Partial failure returns results from successful agents plus error entries for failed agents"
    - "Total failure returns empty results array with all error entries"
  artifacts:
    - path: "get-shit-done/bin/adapters/codex.cjs"
      provides: "Async codex invocation"
      exports: ["detect", "invoke", "invokeAsync", "CLI_NAME"]
    - path: "get-shit-done/bin/adapters/gemini.cjs"
      provides: "Async gemini invocation"
      exports: ["detect", "invoke", "invokeAsync", "CLI_NAME"]
    - path: "get-shit-done/bin/adapters/opencode.cjs"
      provides: "Async opencode invocation"
      exports: ["detect", "invoke", "invokeAsync", "CLI_NAME"]
    - path: "get-shit-done/bin/gsd-tools.cjs"
      provides: "invoke-all subcommand in coplanner group"
      contains: "case 'invoke-all'"
  key_links:
    - from: "get-shit-done/bin/gsd-tools.cjs"
      to: "get-shit-done/bin/adapters/*.cjs"
      via: "loadAdapter(agentName).invokeAsync()"
      pattern: "adapter\\.invokeAsync"
    - from: "get-shit-done/bin/gsd-tools.cjs"
      to: "Promise.allSettled"
      via: "parallel invocation of all agent promises"
      pattern: "Promise\\.allSettled"
---

<objective>
Add async parallel invocation infrastructure: `invokeAsync()` to each CLI adapter and `coplanner invoke-all` command to gsd-tools.cjs.

Purpose: Enable true parallel invocation of multiple external agents at a single checkpoint, reducing total review time from sum-of-agents to max-of-agents.
Output: Three updated adapters with async exports, one new gsd-tools.cjs subcommand.
</objective>

<execution_context>
@/Users/zpyoung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zpyoung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@get-shit-done/bin/adapters/codex.cjs
@get-shit-done/bin/adapters/gemini.cjs
@get-shit-done/bin/adapters/opencode.cjs
@get-shit-done/bin/gsd-tools.cjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add invokeAsync() to all three CLI adapters</name>
  <files>
    get-shit-done/bin/adapters/codex.cjs
    get-shit-done/bin/adapters/gemini.cjs
    get-shit-done/bin/adapters/opencode.cjs
  </files>
  <action>
Add an `invokeAsync(prompt, options)` function to each adapter that returns a Promise resolving to the same `{text, cli, duration, exitCode, error, errorType}` schema as the existing sync `invoke()`. The function must:

1. Add `const { exec } = require('child_process');` to the require block at the top of each file (alongside existing `execSync` import — destructure both from the same require).
2. Use `child_process.exec` (async, callback-based) instead of `execSync` — this is CRITICAL for true parallelism. Wrapping `execSync` in a Promise does NOT achieve parallelism.
3. Include the agent/CLI name AND a random suffix in the temp filename to prevent collisions during parallel execution: `gsd-${CLI_NAME}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}.txt`
4. Handle the `writeFileSync` failure case — resolve with error result, do not reject.
5. Always resolve (never reject) — error results use the same schema with `text: null` and populated `error`/`errorType` fields.
6. Clean up temp file in the callback (after exec completes), not in a finally block.
7. Apply `options.timeout` to the `exec` call's `timeout` option for per-agent timeout isolation.
8. Preserve each adapter's unique logic:
   - **codex.cjs**: Command is `cat "${tmpFile}" | codex exec - --ephemeral --full-auto --skip-git-repo-check`, optional `-m` flag.
   - **gemini.cjs**: Command is `cat "${tmpFile}" | gemini -p --output-format json`, optional `-m` flag. Pass `sanitizeEnv(process.env)` as `env` option. Parse JSON response to extract `parsed.response || stdout.trim()`.
   - **opencode.cjs**: Command is `cat "${tmpFile}" | opencode run --format json`, optional `-m` flag. Use existing `extractOpenCodeResponse(stdout)` for response parsing.

Update each `module.exports` to include `invokeAsync`: `module.exports = { detect, invoke, invokeAsync, CLI_NAME };`

Do NOT modify the existing `invoke()` or `detect()` functions. The sync API must remain unchanged.
  </action>
  <verify>
Verify each adapter file:
1. `grep 'invokeAsync' get-shit-done/bin/adapters/codex.cjs` returns function definition and module.exports
2. `grep 'invokeAsync' get-shit-done/bin/adapters/gemini.cjs` returns function definition and module.exports
3. `grep 'invokeAsync' get-shit-done/bin/adapters/opencode.cjs` returns function definition and module.exports
4. `grep "exec}" get-shit-done/bin/adapters/*.cjs` confirms async exec is imported (not just execSync)
5. `node -e "const a = require('./get-shit-done/bin/adapters/codex.cjs'); console.log(typeof a.invokeAsync)"` outputs "function"
6. `node -e "const a = require('./get-shit-done/bin/adapters/gemini.cjs'); console.log(typeof a.invokeAsync)"` outputs "function"
7. `node -e "const a = require('./get-shit-done/bin/adapters/opencode.cjs'); console.log(typeof a.invokeAsync)"` outputs "function"
8. Existing sync exports still work: `node -e "const a = require('./get-shit-done/bin/adapters/codex.cjs'); console.log(typeof a.invoke, typeof a.detect)"` outputs "function function"
  </verify>
  <done>All three adapters export invokeAsync() returning a Promise with the standard result schema. Existing sync invoke() and detect() unchanged. Temp file names include CLI name + random suffix for collision prevention.</done>
</task>

<task type="auto">
  <name>Task 2: Add coplanner invoke-all command to gsd-tools.cjs</name>
  <files>get-shit-done/bin/gsd-tools.cjs</files>
  <action>
Add a new `invoke-all` case to the coplanner subcommand switch (after the existing `agents` case, before `default`).

**Command interface:**
```
node gsd-tools.cjs coplanner invoke-all --checkpoint {name} --prompt-file {path} [--agents {csv}] [--timeout {ms}] [--model {name}] [--raw]
```

Flags:
- `--prompt-file` (required): Path to a temp file containing the review prompt. Command reads file content internally. This avoids shell quoting issues with large artifacts.
- `--checkpoint` (optional): Checkpoint name to resolve agents from config via existing `getAgentsForCheckpoint()`.
- `--agents` (optional): Explicit CSV list of agent names (e.g., `codex,gemini`). Takes precedence over `--checkpoint` if both provided.
- `--timeout` (optional): Timeout in ms passed to each adapter (default from config `co_planners.timeout_ms` or 120000).
- `--model` (optional): Model name passed to each adapter.
- At least one of `--checkpoint` or `--agents` must be specified.

**Implementation — add async function `cmdCoplannerInvokeAll`:**

1. Check kill switch via `checkKillSwitch(cwd)`. If disabled, output `{ results: [], skipped: true, reason: 'co-planners disabled' }` and return.
2. Read prompt from `--prompt-file` path via `fs.readFileSync`. Error if file not found.
3. Resolve agents list: if `--agents` provided, split on comma; else if `--checkpoint` provided, call `getAgentsForCheckpoint(cwd, checkpoint)` and use `.agents`. Error if no agents resolved.
4. Resolve timeout: use `--timeout` if provided, else read from config `co_planners.timeout_ms`, else default 120000.
5. Build promises array: for each agent name, call `loadAdapter(agentName)`. If adapter missing or has no `invokeAsync`, create an immediately-resolved error entry `{ agent, status: 'error', response: null, error: 'NO_ADAPTER', errorType: 'NO_ADAPTER', duration: 0 }`. Otherwise call `adapter.invokeAsync(prompt, { timeout, model })` and `.then()` map result to `{ agent, status: result.error ? 'error' : 'success', response: result.text, error: result.error || null, errorType: result.errorType || null, duration: result.duration }`.
6. `const settled = await Promise.allSettled(promises)` — use `allSettled` not `all` to handle partial failures.
7. Map settled results: `fulfilled` -> use `.value`, `rejected` -> `{ agent: 'unknown', status: 'error', response: null, error: r.reason?.message, errorType: 'PROMISE_REJECTED', duration: 0 }`.
8. Output `{ results: formatted }` via existing `output()` function. For `--raw` mode, display a summary table: one line per agent with status and duration.

**Wire into coplanner switch:**
Add `case 'invoke-all':` in the coplanner subcommand switch, parse args, and call `await cmdCoplannerInvokeAll(...)`.

Update the `default` error message to include `invoke-all` in the list of valid subcommands.
  </action>
  <verify>
1. `grep "case 'invoke-all'" get-shit-done/bin/gsd-tools.cjs` confirms the new case exists
2. `grep "cmdCoplannerInvokeAll" get-shit-done/bin/gsd-tools.cjs` confirms the handler function exists
3. `grep "Promise.allSettled" get-shit-done/bin/gsd-tools.cjs` confirms proper partial-failure handling
4. `grep "prompt-file" get-shit-done/bin/gsd-tools.cjs` confirms the --prompt-file flag is parsed
5. `node get-shit-done/bin/gsd-tools.cjs coplanner invoke-all 2>&1 | head -5` outputs an error about missing arguments (confirms command is wired in)
6. Verify the default error message includes `invoke-all`: `grep "invoke-all" get-shit-done/bin/gsd-tools.cjs`
  </verify>
  <done>The `coplanner invoke-all` command accepts `--prompt-file`, `--checkpoint`, `--agents`, `--timeout`, and `--model` flags. It invokes all resolved agents in true parallel via Promise.allSettled(), returns JSON array of results with per-agent status, and handles kill switch, adapter loading failures, and partial failures gracefully.</done>
</task>

</tasks>

<verification>
1. All three adapters export `invokeAsync` alongside existing `invoke` and `detect`
2. `invoke-all` command is accessible via `node gsd-tools.cjs coplanner invoke-all`
3. Promise.allSettled is used (not Promise.all) for partial failure handling
4. Temp file collision prevention includes CLI name + random suffix
5. Kill switch check prevents invocation when disabled
6. No new npm dependencies introduced
</verification>

<success_criteria>
- Each adapter's `invokeAsync()` uses `child_process.exec` (async) not `execSync` wrapped in Promise
- `coplanner invoke-all` returns `{ results: [{agent, status, response, error, errorType, duration}] }` JSON
- Per-agent timeout isolation: each `exec` call has its own timeout option
- Existing sync `coplanner invoke` command still works unchanged
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-agent-orchestration/09-01-SUMMARY.md`
</output>
